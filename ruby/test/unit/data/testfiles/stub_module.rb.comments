#     mod <=> other_mod   => -1, 0, +1, or nil
#     mod <= other   =>  true, false, or nil
#     mod < other   =>  true, false, or nil
#     mod === obj    => true or false
#     obj == other        => true or false
#     obj.equal?(other)   => true or false
#     obj.eql?(other)     => true or false
#     obj == other        => true or false
#     obj.equal?(other)   => true or false
#     obj.eql?(other)     => true or false
#     mod >= other   =>  true, false, or nil
#     mod > other   =>  true, false, or nil
#     alias_method(new_name, old_name)   => self
#     append_features(mod)   => mod
#     attr(symbol, writable=false)    => nil
#     attr_accessor(symbol, ...)    => nil
#     attr_reader(symbol, ...)    => nil
#     attr_writer(symbol, ...)    => nil
#     mod.autoload?(name)   => String or nil
#    A.autoload?(:B)            # => "b"
#     mod.autoload(name, filename)   => nil
#     mod.class_eval(string [, filename [, lineno]])  => obj
#     mod.module_eval {|| block }                     => obj
#     mod.module_exec(arg...) {|var...| block }       => obj
#     mod.class_exec(arg...) {|var...| block }        => obj
#     mod.module_exec(arg...) {|var...| block }       => obj
#     mod.class_exec(arg...) {|var...| block }        => obj
#     obj.class_variable_defined?(symbol)    => true or false
#     mod.class_variable_get(symbol)    => obj
#     obj.class_variable_set(symbol, obj)    => obj
#     mod.class_variables   => array
#     mod.const_defined?(sym)   => true or false
#     mod.const_get(sym)    => obj
#     mod.const_missing(sym)    => obj
#     mod.const_set(sym, obj)    => obj
#     Module.constants   => array
#     mod.constants    => array
#     define_method(symbol, method)     => new_method
#     define_method(symbol) { block }   => proc
#     define_method(symbol, method)     => new_method
#     define_method(symbol) { block }   => proc
#     extend_object(obj)    => obj
#     mod.include?(module)    => true or false
#     include(module, ...)    => self
#     mod.instance_method(symbol)   => unbound_method
#       ?a => instance_method(:do_a),
#       ?d => instance_method(:do_d),
#       ?e => instance_method(:do_e),
#       ?v => instance_method(:do_v)
#     mod.instance_methods(include_super=true)   => array
#     mod.method_defined?(symbol)    => true or false
#     mod.class_eval(string [, filename [, lineno]])  => obj
#     mod.module_eval {|| block }                     => obj
#     mod.module_exec(arg...) {|var...| block }       => obj
#     mod.class_exec(arg...) {|var...| block }        => obj
#     mod.module_exec(arg...) {|var...| block }       => obj
#     mod.class_exec(arg...) {|var...| block }        => obj
#     module_function(symbol, ...)    => self
#     mod.name    => string
#     Module.nesting    => array
#     Module.new                  => mod
#     Module.new {|mod| block }   => mod
#     private                 => self
#     private(symbol, ...)    => self
#     mod.private_class_method(symbol, ...)   => mod
#     mod.private_instance_methods(include_super=true)    => array
#     mod.private_method_defined?(symbol)    => true or false
#     protected                => self
#     protected(symbol, ...)   => self
#     mod.protected_instance_methods(include_super=true)   => array
#     mod.protected_method_defined?(symbol)   => true or false
#     public                 => self
#     public(symbol, ...)    => self
#     mod.public_class_method(symbol, ...)    => mod
#     mod.public_instance_methods(include_super=true)   => array
#     mod.public_method_defined?(symbol)   => true or false
#     remove_class_variable(sym)    => obj
#     remove_const(sym)   => obj
#     remove_method(symbol)   => self
#     mod.to_s   => string
#     undef_method(symbol)    => self
